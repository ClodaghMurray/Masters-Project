---
title: "GSE37614 - WGCNA"
author: "Clodagh Murray"
date: "6/2/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Co-expression Network

```{r, message = F}
options(stringsAsFactors = FALSE)
library(Rcpp)
library(gplots)
library(plotly)
library(dplyr)
library(WGCNA)
library(genefilter)
```

# Reduce dataset - remove low variance genes
```{r}
# read in quantile normalized log2 data with batch effects removed
rm_batch <- read.csv("/home/clodagh/MASTERS PROJECT/GSE37614/GSE37614_counts_matrix.txt", header = T, sep= "\t")
rm_batch <- as.matrix(rm_batch)
rm_batch <- varFilter(rm_batch) #filter threshold top 50% of most variable genes 
dim(rm_batch) # top 70% most variable genes of data
```

```{r}
#rows as samples, columns as genes
datExpr <- as.data.frame(t(rm_batch))
datExpr=datExpr[, rank(-k,ties.method="first" )<=3600]
write.csv(datExpr, file = '/home/clodagh/MASTERS PROJECT/GSE37614/datExpr.csv', row.names = T)
#write.csv(norm_counts, file = "/home/clodagh/MASTERS PROJECT/GSE37614/norm_counts_varFiltered.csv", row.names = T)
## Step by step WGCN construction
gsg = goodSamplesGenes(datExpr, verbose = 3);
gsg$allOK
```


## Detect outliers

```{r}
sampleTree = hclust(dist(datExpr), method = "average");
# Plot the sample tree: Open a graphic output window of size 12 by 9 inches
# The user should change the dimensions if the window is too large or too small.
sizeGrWindow(12,9)
#pdf(file = "/home/clodagh/MASTERS PROJECT/GSE37614/sampleClustering.pdf", width = 12, height = 9);
par(cex = 0.6);
par(mar = c(0,4,2,0))
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5, cex.axis = 1.5, cex.main = 2)
# Plot a line to show the cut
abline(h = 60, col = "red")

```
# Make metadata with matching colnames
```{r}
meta <- read.csv("/home/clodagh/MASTERS PROJECT/GSE37614/metadata.csv", sep = "\t")
meta[23,]$Cancer_Subtype <- "Her2+"
samps = rownames(datExpr);
traitRows = match(samps, rownames(meta))
datTraits = meta[traitRows, ]
ind <- as.numeric(as.factor(datTraits$Cancer_Subtype))
TNBC <- ifelse(ind == 3, 1, 0)
ER <- ifelse(ind == 1, 1, 0)
HER <- ifelse(ind == 2, 1, 0)

# sample traits dataframe
datTraits <- data.frame(TNBC, ER, HER)

# Form a data frame analogous to expression data that will hold the clinical traits.
rownames(datTraits) = samps

# check pheontype data corresponds to exp data
table(rownames(datTraits) == rownames(datExpr))   
```
Network Construction; selecting a similarity metric

#thresholding connections; all nodes connected in wgcna network; soft thresholding emphasises stronger connections relative to weaker ones 
#could also use a hard threshold if doesnt work and just select nodes and edges above the threshold
#Choosing the soft-thresholding power: analysis of network topology
#pickSoftThreshold that performs the analysis of network topology and aids the user in choosing a proper soft-thresholding power to achieve scale free topology


```{r}
powers= c(c(1:10), seq(from =12, to=30, by=2)) #choosing a set of soft-thresholding powers
sft = pickSoftThreshold(datExpr, powerVector=powers, dataIsExpr = T, networkType = "signed", verbose =2, corFnc = "bicor") #call network topology analysis function
```

```{r}
sizeGrWindow(9,5)
par(mfrow= c(1,2))
cex1=0.9
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2], xlab= "Soft Threshold (power)", ylab="Scale Free Topology Model Fit, signed R^2", type= "n", main= paste("Scale independence"))
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2], labels=powers, cex=cex1, col="red")
abline(h=0.85, col="red")
plot(sft$fitIndices[,1], sft$fitIndices[,5], xlab= "Soft Threshold (power)", ylab="Mean Connectivity", type="n", main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1, col="red")

```



# Adjacency - check scale freeness
```{r}
softpower = 19
#plot adj in next section
adj= adjacency(datExpr,type = "signed", power = softpower, corFnc = "bicor")
#head(adj[1:5,1:5])
# corFnc defaults to Pearson 
# When you have relatively few genes (<5000) use the following code
k=as.vector(apply(adj,2,sum, na.rm=T))
# When you have a lot of genes use the following code
#k=softConnectivity(datE=norm_counts, power=22, type = "signed")
# Plot a histogram of k and a scale free topology plot
sizeGrWindow(10,5)
par(mfrow=c(1,2))
hist(k)
# Relatiely scale free - Poor fit to scale free topology may also indicate
# the presence of array outliers. Might remove the Her2+ER+ sample?
scaleFreePlot(k, main="Check scale free topology\n")
```


# TOM from adjacency
```{r}
# topological overlap matrix: transform adj into TOM to minimise effects of noise and spurious associations
# The TOM describes how well connected the genes are in respect of how many neighbors they share. 
# idea of TOM is to count the direct connection strengths as well as connection strengths “mediated” by shared neighbors
# signed network: preserves the sign of the relationship between the nodes while taking account the connections through shared neighbors in the same way the standard unsigned TOM does.

dissTOM <- TOMdist(adj)

#save TOM 
write.table(dissTOM, file = '/home/clodagh/MASTERS PROJECT/GSE37614/dissADJ.txt', sep ='\t', col.names = T, row.names = T)
#take the distance of the TOM matrix
head(dissTOM[1:5,1:5])

```

Plot the adjacency matrix
```{r}
gene_ids <-rownames(adj)
#plot adjacency matrix
adj <- matrix(adj, nrow=nrow(adj))
rownames(adj) <- gene_ids
colnames(adj) <- gene_ids
#topological overlap matrix 
#minimise noise and spurious associations, tranform into TOM and calculate corresponding similarity
#take random sample of 500 and plot 
heatmap_indices <- sample(nrow(adj), 500)
#we can still see here a subset of genes highly correlated... not ideal as ideally want sparseness but can see some genes v similiar correlation of expression
#command used to plot multiple adj.
#pdf(file="/home/clodagh/MASTERS PROJECT/GSE37614/adj_matrix_22thresh.pdf")
heatmap.2(t(adj[heatmap_indices, heatmap_indices]),
            col=redgreen(75),
            labRow=NA, labCol=NA, 
            trace='none', dendrogram='row',
            xlab='Gene', ylab='Gene',
            main='     Adjacency matrix (pearson, power:19)',
            density.info='none', revC=TRUE)
#dev.off()
```

Module Definition; hierarchical clustering and tree cutting to define modules of co-expressed genes

```{r}
# Call the hierarchical clustering function from flashclust as faster than base hclust
geneTree = flashClust::hclust(as.dist(dissTOM), method = "average");

# average standard param; average dissimilarities between all objects
# Plot the resulting clustering tree (dendrogram)
# each vertical line corresponds to a gene, clusters correspond to 'leafs ' of genes
# dense branches indicate highly inter-connected, co-expressed genes
# module identification = identification of individual branches
# selecting the cut height leads to v different results, NB step
# use the dynamic tree cut package: bottom-up approach, merge branches evaluate (no of objects, gap between branches etc.),if meet criteria for being a module called seperate modules, otherwise merge
# can merge branches based on similiar eigengene values
sizeGrWindow(12,9)
plot(geneTree, xlab="", sub="", main = "Gene clustering on TOM-based dissimilarity",
labels = FALSE, hang = 0.04)

```

```{r}
# Module identification using dynamic tree cut: 
#step 1: detection of clusters
#deepsplit; how finely branches should be split; higher value more smaller modules, lower value fewer larger modules
#PAM stage, turn PAM on or off; basically allows assigning more outlying objects to clusters
#This Partitioning Around Medoids-like step is based on average dissimilarities between unlabeled objects and the basic clusters detected in step 1 
#w/o PAM more grey (unassigned), with PAM dendogram can be difficult to interpret
#issue with tree cutting is its heuristic (potentially not optimal) for deciding if branch is a cluster
# want large modules, so we set the minimum module size relatively high:
minModuleSize = 30
dynamicMods = cutreeDynamic(dendro = geneTree, distM = dissTOM,
deepSplit = 2, pamStage = F, pamRespectsDendro = FALSE,
minClusterSize = minModuleSize);
table(dynamicMods) # 39 modules detected
collectGarbage()

```


Plot dendogram, modules and traits
```{r}
# Convert numeric lables into colors
dynamicColors = labels2colors(dynamicMods)
table(dynamicColors)
# Convert traits to a color representation: white means low, red means high, grey means missing entry
traitColors = data.frame(labels2colors(datTraits))
dim(traitColors)
# Plot the dendrogram and colors underneath
sizeGrWindow(8,6)
pdf(file = '/home/clodagh/MASTERS PROJECT/GSE37614/gene_dend(deepsp = 2, PAM = T).pdf', wi = 9, he = 6)
plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut",
dendroLabels = FALSE, hang = 0.03,
addGuide = TRUE, guideHang = 0.05,
main = "Gene dendrogram and module colors") 
                    
#dev.off()
```


Merge modules with similiar expression profiles since genes could be highly co-expressed
To calculate co-expression similarity of modules, calculate their eigengene value (a i-D vector that summarises the expression data of the genes that form a module, calculated from the first prinical component of the expression data)

Eigengenes represent module in mathematical calculations; can check for correlation with one another, can cluster, correlate with traits (i.e. case vs control)


```{r}
# Calculate eigengenes, match colours to dendogram
MEList = moduleEigengenes(datExpr, colors = dynamicColors)
MEs = MEList$eigengenes
# Calculate dissimilarity of module eigengenes
MEDiss = 1-cor(MEs);
# Cluster module eigengenes
METree = hclust(as.dist(MEDiss), method = "average");
# Plot the result
MEDissThres = 0.25 #correlation of 70% to merge. 
sizeGrWindow(7, 6)
pdf(file = '/home/clodagh/MASTERS PROJECT/GSE37614/module_eigengene_clustering.pdf', wi = 9, he = 6)
plot(METree, main = "Clustering of module eigengenes",
xlab = "", sub = "")
abline(h=MEDissThres, col = "red")
#dev.off()
```

```{r}
# Call an automatic merging function; merge modules with eigengenes similarity >750%
merge = mergeCloseModules(datExpr, dynamicColors, cutHeight = MEDissThres, verbose = 3)
# The merged module colors
mergedColors = merge$colors;
# Eigengenes of the new merged modules:
mergedMEs = merge$newMEs;
mergedMEs
#plot shows the orignal module definition by dynamic tree cut and then the merging of modules via correlation in eigengene values
sizeGrWindow(12, 9)
#
pdf(file = '/home/clodagh/MASTERS PROJECT/GSE37614/Cluster_dend(pears22,eign_thresh=.2).pdf', wi = 9, he = 6)
plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors),
c("Dynamic Tree Cut", "Merged dynamic"),
dendroLabels = FALSE, hang = 0.03,
addGuide = TRUE, guideHang = 0.05)
#dev.off()
```


# plot heatmap of genes to visualise 
# light colours, little overlap, dark colours high overlap (= modules)
# v slow to plot..take subset of genes to speed up (take 4k)
#TOM in squares, rows are genes and columns and sorted by the clustering algorithm

```{r}
#heatmap colours
myheatcol = colorpanel(250,'red',"orange",'lemonchiffon')

# For reproducibility, we set the random seed
set.seed(10);
#nSelect = 4000
select = sample(ncol(datExpr), size = 3000);
selectTOM = dissTOM[select, select];
# no simple way of restricting a clustering tree to a subset of genes, so we must re-cluster.
selectTree = hclust(as.dist(selectTOM), method = "average")
selectColors = mergedColors[select];
sizeGrWindow(9,9)
# Taking the dissimilarity to a power, makes the plot more informative by effectively changing the color palette; 
#setting the diagonal to NA also improves the clarity of the plot
plotDiss = selectTOM^9;
diag(plotDiss) = NA;
#takes long time to write out to pdf
#pdf(file = '/home/clodagh/MASTERS PROJECT/GSE37614/gene_network_heatmap.pdf', wi = 9, he = 6)
TOMplot(plotDiss, selectTree, selectColors, main = "Network heatmap plot", col= myheatcol)
#dev.off()
```



Plot eigengene correlation networks: 
Look at relationships among the found modules. One can use the eigengenes as representative profiles and quantify module similarity by eigengene correlation. 

```{r}
# Plot the dendrogram
pdf(file = '/home/clodagh/MASTERS PROJECT/GSE37614/eigengene_dendogram.pdf', wi = 9, he = 6)
plotEigengeneNetworks(mergedMEs, "Eigengene dendrogram", marDendro = c(0,4,2,0), marHeatmap = c(3,4,2,2),
plotHeatmaps = T)
#dev.off()
```

Use the merged module colors in mergedColors. Save the relevant variables for use in subsequent parts of the analysis

```{r}
# Rename to moduleColors
moduleColors = mergedColors
# Construct numerical labels corresponding to the colors
colorOrder = c("grey", standardColors(50));
moduleLabels = match(moduleColors, colorOrder)-1;
MEs = mergedMEs
# Save module colors and labels for use in subsequent parts
save(MEs, moduleLabels, moduleColors, geneTree, file = "/home/clodagh/MASTERS PROJECT/GSE37614/network_construction.RData")
```



Module trait relationship plot 
Identify modules significantly associated with traits
#Correlate eigengene values with condition and assess gene significance (GS) measures; statistical significance between the oth node profile and the sample traits
#Each entry module eigengene correlated with the trait
```{r}
# Define numbers of genes and samples
nGenes = ncol(datExpr);
nSamples = nrow(datExpr);
head(datExpr)

# Recalculate MEs with color labels
# correlate with subtype 
MEs0 = moduleEigengenes(datExpr, moduleColors)$eigengenes
MEs = orderMEs(MEs0)
moduleTraitCor = cor(MEs, datTraits, use = "p"); #pearson correlation to assess correlation between merged eigengenes and traits
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);

# Form a data frame analogous to expression data that will hold the clinical traits.
samples = rownames(datExpr);
samples
dim(moduleTraitCor)


sizeGrWindow(12,6)
pdf(file = '/home/clodagh/MASTERS PROJECT/GSE37614/MTR_plot.pdf')
# Will display correlations and their p-values
textMatrix = paste(signif(moduleTraitCor, 2), "\n(",
signif(moduleTraitPvalue, 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCor)
par(mar = c(10, 10, 5, 5));


# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = moduleTraitCor,
xLabels = names(datTraits),
yLabels = names(MEs),
ySymbols = names(MEs),
colorLabels = FALSE,
colors = blueWhiteRed(50),
textMatrix = textMatrix,
setStdMargins = FALSE,
cex.text = 0.5,
zlim = c(-1,1),
main = paste("Module-trait relationships"))
#dev.off()
```



Intramodular analysis;
A microarray sample trait can be used to define a trait-based gene significance measure as the absolute correlation between the trait and the expression profiles

Identifying genes with high GS and MM
Gene relationship to trait and important modules: Gene Significance and Module Membership
Quantify associations of individual genes with trait of interest by defining Gene Significance GS as (the absolute value of) the correlation between the gene and the trait. 
For each module, also define a quantitative measure of module membership MM as the correlation of the module eigengene and the gene expression profile. This allows us to quantify the similarity of all genes on the array to every module.

```{r}
#focus on modules associated with HER2
HER2 <- as.data.frame(datTraits$HER);
names(HER2) = "HER2"
# names (colors) of the modules
modNames = substring(names(MEs), 3)
# quantify associations of individual genes with our trait of interest by defining Gene Significance GS as the absolute value of the correlation between the gene and the trait
#For each module, we also define a quantitative measure of module membership MM as the correlation of the module eigengene and the gene expression profile. 
geneModuleMembership = as.data.frame(cor(datExpr, MEs, use = "p"));
MMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples));
names(geneModuleMembership) = paste("MM", modNames, sep="");
names(MMPvalue) = paste("p.MM", modNames, sep=""); #p value for module membership of each gene
geneTraitSignificance = as.data.frame(cor(datExpr, HER2, use = "p")); #correlation of each gene  with trait
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples)); #the resultant p value
names(geneTraitSignificance) = paste("GS.", names(HER2), sep="");
names(GSPvalue) = paste("p.GS.", names(HER2), sep="");
```


GS:Correlating gene significance with clinical traits

```{r}
#average gene significance as a measure of module significance 
GS2=as.numeric(cor(HER,datExpr, use="p"))

GeneSignificance=abs(GS2)
# Next module significance is defined as average gene significance.
ModuleSignificance=tapply(GeneSignificance, moduleColors, mean, na.rm=T)
sizeGrWindow(12,6)
pdf(file = '/home/clodagh/MASTERS PROJECT/GSE37614/gene_sig_barplot.pdf')
plotModuleSignificance(GeneSignificance, moduleColors) #could also use this to define pathway membership etc.
ModuleSignificance
#dev.off()
```


```{r}
MS_order <- sort(ModuleSignificance)

# calculate the module membership values (aka. module eigengene based connectivity kME)
datKME <- signedKME(datExpr, MEs )
datKME #ie how correlated, anticorrelated genes are with module eigengenes
pdf(file = '/home/clodagh/MASTERS PROJECT/GSE37614/GSvsMMplot.pdf')
colorOfColumn = substring(names(MEs), 3)
colorOfColumn
par(mfrow = c(2, 2))
selectModules = c("darkolivegreen", "blue", "violet")
#par(mfrow = c(2, length(selectModules)/2))
for (module in selectModules) {
    column = match(module, colorOfColumn)
    print(column)
    restModule = dynamicColors == module
    verboseScatterplot(datKME[restModule, column], GS2[restModule], xlab = paste("MM ", 
        module, "module"), ylab = "GS.HER2", main = paste("kME.", module, 
        "vs. GS"), col = module,  bty="n" , abline = T, pch = 16 , cex = 1, cex.axis = 1, cex.main = 1)
}
dev.off()
```


Perform GSEA of significant modules?




# Intramodular Connectivity

```{r}
#calculate intramodular connectivty
connect.measures <- intramodularConnectivity(adj, moduleColors) #module colours vector equilivant to dynamic colours 
#gene significance value for HER - take abs value of GS2
GeneSignificance <- abs(GS2)
head(connect.measures)
MS_order

#relationship between gene significance in a intramodular connectivity
pdf(file = '/home/clodagh/MASTERS PROJECT/GSE37614/GSvsIntraModConnect.pdf')
colorlevels=unique(moduleColors)
rm_colorlevels = c("purple","darkmagenta","lightgreen","darkgreen", "orangered4","grey60", "turquoise", "yellow")
colorlevels <- colorlevels[! colorlevels %in% rm_colorlevels]
colorlevels
#sizeGrWindow(9,6)
pdf(file = '/home/clodagh/MASTERS PROJECT/GSE37614/GSvsIntraModConnect_filtered.pdf')
par(mfrow=c(2,as.integer(0.5+length(colorlevels)/2)))
par(mar = c(4,5,3,1))
for (i in c(1:length(colorlevels)))
{
whichmodule=colorlevels[[i]];
restrict1 = (moduleColors==whichmodule); #could I use this to restrict bootstrap analysis to corresponding module?
verboseScatterplot(connect.measures$kWithin[restrict1],
GeneSignificance[restrict1], col=moduleColors[restrict1],
main=whichmodule,
xlab = "Connectivity", ylab = "Gene Significance", abline = TRUE, cex.lab = 1, cex = 1, pch = 16, cex.main = 1)
}
#can see that the orangered4, pink, darkgreen and salmon hub genes (high connectivity) tend to have high gene significance (correlation with the trait)
#this shows how well connected each gene is within the module
#want genes highly connected with high trait significance
dev.off()
```

Write out results for genes with their module membership values

```{r}
# modules of interest for HER2
names(datExpr)[moduleColors=="darkolivegreen"] 
names(datExpr)[moduleColors== "blue"] 
names(datExpr)[moduleColors== "violet"] 
#create geneinfo dataframe
geneInfo0 <- data.frame(Entrez_ID = names(datExpr), 
                       module_Colour = moduleColors,
                       geneTraitSignificance,
                       GSPvalue)
#order genes in df by significance for HER2 status
modOrder = order(-abs(cor(MEs, HER2, use = "p")));
for (mod in 1:ncol(geneModuleMembership))
{
oldNames = names(geneInfo0)
geneInfo0 = data.frame(geneInfo0, geneModuleMembership[, modOrder[mod]],
MMPvalue[, modOrder[mod]]);
names(geneInfo0) = c(oldNames, paste("MM.", modNames[modOrder[mod]], sep=""),
paste("p.MM.", modNames[modOrder[mod]], sep=""))
}
# Order the genes in the geneInfo variable first by module color, then by geneTraitSignificance
geneOrder = order(geneInfo0$module_Colour, -abs(geneInfo0$GS.HER2));
geneInfo = geneInfo0[geneOrder, ]
#write df to file:
write.csv(geneInfo, file = "/home/clodagh/MASTERS PROJECT/GSE37614/geneInfo.csv", row.names = F)
```


## Identify genes with high GS and MM 

Genes highly significantly associated with a trait are often also the most important (central) elements of modules associated with the trait

```{r}
module = "darkolivegreen"
column = match(module, modNames);
moduleGenes = moduleColors==module;
sizeGrWindow(7, 7);
par(mfrow = c(1,1));
verboseScatterplot(abs(geneModuleMembership[moduleGenes, column]),
abs(geneTraitSignificance[moduleGenes, 1]),
xlab = paste("Module Membership in", module, "module"),
ylab = "Gene significance for HER2 status",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, col = module)
```


```{r}
module = "blue"
column = match(module, modNames);
moduleGenes = moduleColors==module;
sizeGrWindow(7, 7);
par(mfrow = c(1,1));
verboseScatterplot(abs(geneModuleMembership[moduleGenes, column]),
abs(geneTraitSignificance[moduleGenes, 1]),
xlab = paste("Module Membership in", module, "module"),
ylab = "Gene significance for HER2 status",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, col = module)
```

```{r}
module = "violet"
column = match(module, modNames);
moduleGenes = moduleColors==module;
sizeGrWindow(7, 7);
par(mfrow = c(1,1));
verboseScatterplot(abs(geneModuleMembership[moduleGenes, column]),
abs(geneTraitSignificance[moduleGenes, 1]),
xlab = paste("Module Membership in", module, "module"),
ylab = "Gene significance for HER2 status",
main = paste("Module membership vs. gene significance\n"),
cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, col = module)
```


## Annotate probes
```{r}
library(org.Hs.eg.db)
hs <- org.Hs.eg.db
probes = names(datExpr)
probes2annot = AnnotationDbi::select(hs, 
       keys = probes,
       columns = c("ENTREZID", "SYMBOL"),
       keytype = "SYMBOL")
entrez <- match(probes, probes2annot$SYMBOL)
# the following is the number or probes without annotation:
sum(is.na(probes2annot))
# Should return 0.
```












